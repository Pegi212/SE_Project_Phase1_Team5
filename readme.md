# SE_Project_Phase1_Team5
Group Division (Phase I) # Team Information
## Team Name: [SE_Project_Team5]

## Team Leader:
- **Name:** [Pegi Peqini]
- **GitHub Username:** [Pegi212]

## Team Members:
1. [Enxhi Brahimaj] - GitHub: [Enxhi5]
2. [Pegi Peqini]- GitHub: [Pegi212]
3. [Sindi Berberaj]- GitHub: [Sindi111]
4. [Kevin Kaloshi] - GitHub: [Kevi050]

# Project Details

## Project Title: [Dermo - Aesthetic Appointment System]

## Problem Statement: 
[During our analysis and communication with our client we highlighted some of the main challenges faced by him while using his current system . For our client it is difficult to deal with his current appointment system,  he faces difficulties while navigating in the system during a registration process. This creates complexities because the contact information is being entered incorrectly sometimes . He faces difficulties in time management and also in monitoring the schedules,  appointments and keeping track of the patients . Another problem identified after the analysis was the irregular information storage , improper software quality and non-flexible software functionality.]


## Solution Proposed:
[Solution Proposal: In order to overcome these challenges we suggested our client a new  Dermo-Aesthetic appointment system software that will make it easier for patients and dermo-aesthetic doctors to interact with each-other without facing difficulties , we aim to offer our client an easy navigation into the system without producing errors during performing each functionality . After identifying these issues and the client’s requirements we aim to produce an effective appointment management system and bring a user-friendly software to monitor and manage each registration , schedules , reminders and patients accurately .]

## Project Scope: Appointment Scheduling Software 
- **Aim**: [Our main objective is to provide an efficient software solution to the clients and healthcare providers . This system will be easy to use and accessible by both parts.
Features : 
Sign-in and sign-up services for both client and doctor’s parts. 
Assure that the information stored is well protected and authentic. 
Client can request appointments by accessing the doctor’s availability in the system
Client can postpone or cancel appointments directly through the system
System keeps track of the client’s historical and personal information
Responsive software designed for each format : Desktop, tablet , device.

Constraints : 
Conformity with laws and health maintenance regulations . 
Reflection of private information and sensitive data protection laws.
Restricted time for testing and documentation of each version of work till the final version. 

              Stakeholders : 
Doctors 
Clients 
Directors and management 
Developers 
  
              Favorable outcome : 
Software being in compliance with all the client’s described specifications and requirements . 
Records stored are structured and well-organized without producing errors
No disturbance during the design , implementation , deployment and testing stages. 
Efficient software performance , meaning that this system actually performs the required functionalities. 


            Timeline : 
Preparations according to planning and collecting all the client’s requirements : 5 days
Design , implement , unit and system testing stages  : 5 weeks 
Deployment and assisting the client’s usage : 5 days 
Operation and maintenance : constant ]

-**Main Objectives:**
  1. [ Develop a functional Dermo-Aesthetic Appointment system that is easy to use and accessible to all.]
  2.[ Provide a platform to ensure that dermo-aesthetic doctors  can manage more effectively and quickly their appointments , timetables , schedules and calendars.]
  3. [To help patients book an appointment faster for their personal needs.]
  4.[Provide a detailed description of the application that the team intends to develop.]
  5.[Include information on the intended users and how the application will address their needs.]




## Application Description:
[This software is dedicated and offers a solution to booking and managing appointments by patient’s and doctor’s sides. By applying an user-friendly interface through the utilization of bootstrap , css and other designing tools and also providing prosperous features the system contributes mainly in the improvement of handling the appointments booking , while leaving each of users satisfied after operating in the system . This software guarantees privacy for each user’s sensitive records and also ensures that the website information is displayed in the proper form through several devices . The application will be developed through using HTML,CSS ,PHP and Bootstrap . This is a sophisticated appointment scheduling tool created to improve user experience, improve the scheduling process, and offer effective resources to admins and clients alike.
Backend and Frontend technologies :
We plan to use PHP programming language to generate this system. On the backend side we organize the project through folders that contain files according to each function the software will provide . Through the back-end side it will be made the connection between PHP files and the database that has the records stored in it. 
In the front-end side we plan to use html, css , bootstrap, and js for the purpose of a friendly interface and easy interaction . 
Database : The database of the project will be according to MySql . After completing the sign-in, sign-up , search, edit and many other operations this information will be either stored or retrieved from the tables of the database.

Doctor requirements :
1.They will view their upcoming sessions scheduled in the system.
2.View patient details.
3.Check the system for their planned appointments.
4.Edit their account in the system.

Patient requirements : 
1.They can easily make appointments through online system .
2.Create a personal account.
3.Check their old booking history in the system.

Security:
User data should be protected by the secure system.There will be used encryption and authentication to prevent unwanted access and it should comply to data protection laws.
Accessibility:
Every user should be able to access the system. It has to comply to accessibility guidelines and provide other means of access such as phone or in-person reservation.
System Availability:
The system will have backup and recovery procedures in order to guarantee that it is always running,it should be available 24/7.]

# Roles and Tasks Distribution

## Team Leader : Pegi Peqini [
 Looked after the project's specifications, designing, implementation, validation and evolution while observing in order to make sure that  it remains on schedule and under the planned budget. 
Correlated the connection among team members, stakeholders, and the client. 
Ensured the chronology of each task while using the incremental model for software development. This way we received feedback , and accommodated the changes in the client’s requirements easier. Addressed any concerns that may occur throughout development. 
Back-end and front-end development.]

## Main Roles and Tasks:
1. [Enxhi Brahimaj] - [Charged with the development of the appointment system back-end elements and sections. Implemented some of the main functionalities of this system : 
Appointment , doctors and settings edition and control (delete , add, update, search and book appointments functionalities )
Ensured the functionalities performed by patients and doctors.
Developed a log-in form where each patient can log into and be part of the website. 
Ensure that the system is scalable, secure, and performant.]


2. [Sindi Berberaj] - [Responsible for website appearance and designing while for plotting simple and friendly user interfaces applicable by both the mobile and internet platforms . 
Made sure that every website visitor has a easy access and interaction with the website without struggling. 
Ensuring also that the website is responsive in every platform . 
Front-end tasks are being developed through the combination and application of html, xml, bootstrap and css. ]

3. [Kevin Kaloshi] - [In charge of the database management where each client’s and doctor’s personal information is stored . 
Creation , implementation , maintenance of the database while making sure that each information can be stored and retrieved quickly and accurately . 
Ensured the modification and search of information by each client and doctor . ]


Phase II: User Requirements and Application Specifications 
Submission Deadline: 18.03.2024, 23:59 
1.	Chosen Development Model: 
We selected the optimal software development model by analyzing some crucial key factors . These factors consisted on : 
•	Development time , particular deadlines and team size 
•	Constant delivery and client frequent feedback
•	Project size and complicatedness of it.
•	Development flexibility 
•	Assessing the risk tolerance 
•	Checking if the project requirements coordinate with the chosen model attributes


Based on the factors mentioned above we came to the conclusion that the best model to go for is Incremental model . The selection of Incremental model depended on our development team size that consists on 4 collaborators versus development time that is speculated to be 6 weeks . Since the time constraints appear short , Incremental model grants the earlier delivery of the product to the client rather than Waterfall model which requires more amount of time to deliver and deploy. 
 The small amount of time does not allow us for a clear and detailed documentation of each version of the project. One of the most beneficial thing that Incremental model provides for us is the client collaboration and feedback , we selected incremental model because our client wants to interact with the project vastly .Various stakeholders have the chance to offer input at different levels of development since the requirements specification , development and validation are inter-leaved in this approach . Client requirements can change due to his preferences so the selection of Incremental model was done for the purpose of making the accommodation and settlement of change effortless and cost-effective , while producing the optimal final version that meets the specified client’s requirements and expectations. 
The division of work in increments enables the effective management and fast advancement of the project. Lastly this approach we intend to follow grants the possibility of constant validation and evolution. Incremental model supports the ongoing testing of each increment added in order to certify that the final version of the product is efficient and high quality. 



2. User Requirements: 
a)	Stakeholders : 
•	Patients : Patients are the fundamental users of this appointment software. They interact with the software while handling their appointments , book the appointments by accessing the particular doctor’s free time , they can edit their personal account in the system or cancel and postpone an appointment due to their preferences. Some of the main functionalities performed by the patient will be : add booking , delete booking , edit settings , sign in , sign out , and log out functionalities. 
•	Doctors : Aesthetic doctors in the clinic represent essential stakeholders who will interact with this software product . The doctor’s job related to the system is to oversee their schedule , watch the bookings displayed in the system , retrieve from the system their particular patient’s personal information in order to get a historical overview of the patient personal health and health issues he might have faced previously. Doctors can delete a particular appointment , delete their account or access settings functionality . 
•	Administrators : Administrators represent another group of key stakeholders in charge of keeping under observation the operational part of the system meaning that the admin is responsible for managing the appointments made in the system , recording the patients , adding , deleting patients or doctors , and editing the settings part. They are responsible for controlling and maintaining user accounts . 

b)	User Stories : 
•	End-users ( Patient, Doctor ) :

For the client / patient : 

As a patient 
I want to book my appointment within the system 
So I can obtain aesthetic health care from my preferred doctor.

Benefit : Appointment booking directly from the system. 

As a patient 
I want to access the doctor’s free and available hours 
So I can manage my time and come at the right time . 

Benefit : Book the appointment according to doctor’s available time. 


As a patient
I want to come up with appropriate information related to my health and update it when needed
So the doctor can be informed and understand me better. 

Benefit : Doctor is well informed , so he can diagnose the patient accurately and the medical prescription is correct. 


As a patient 
I want to cancel my appointments when I cannot come and postpone it
So I can come another time when I am available . 

Benefit : Patients can cancel their appointments or change them in order to come at an appropriate moment without wasting doctor’s available hours .


Doctor’s side: 
                        As a doctor
                        I want to access my appointments in the system 
                        In order to manage my time more effectively. 

                        Benefit : Doctors can check their working hours through the system. 

                       As a doctor 
                       I need to access my patient’s health status 
                       In order to offer up to date and customized aesthetic care solutions to each patient

                      Benefit : Doctors can change patient’s health information in order to come up with 
                      optimal solutions.

                      As a doctor 
                      I need to be informed whether an appointment is canceled or postponed 
                     In order to organize my time properly. 
                      Benefit : Doctor’s can access the canceled appointments . 

                     Administrator’s side : 
                     As an administrator 
                    I need to be able to insert , update , delete the patient’s and doctor’s information and accounts
                    In this way I can help the system progress and reduce unnecessary information.      

                   Benefit : Administrators can perform the functionalities for a better system    management.                  
    
                   As an administrator 
                  I need to have control over the system’s execution and functionalities performance 
                 So I can address each issue faced and operate in an effective system.

                 Benefit : Administrators are informed about the system’s weaknesses and overall performance in order to improve it further . 



3. Functional Requirements: 
a)	Brief description : 
This software product consists on a variety of features which are : 
•	System that provides a sign-in and log-in platform where each new user can be part of , or existing users can log in and make the booking . 
•	After logging into the platform each patient can scroll and search for the doctor they need and make the booking . 
•	System that enables appointment handling by both parties (doctors / patients) , 
•	System that lets you cancel or postpone the appointment based on your preference.
•	System that enables doctors to view each patient personal record . 
•	System that enables the modification of your personal data from the doctor and patient perspective .
•	System that enables you to delete your account in cases when you don’t want to be part of it anymore , from patient and doctor’s side. 

b)	Acceptance Criteria : 

Booking : 
•	Users need to choose the convenient date and particular time for their     appointment    □
•	After doing this the system displays whether this date and time is available , and if it is not it displays which time is available according to the doctor  □
•	After choosing the appropriate time system informs you with a message that your booking is made . □
•	Doctors are notified in both cases (new appointment or cancel appointment) with a message via e-mail.  □
             User’s personal information : 
•	Users are obliged to sign in with valid information and passwords in order to ensure the authorization and privacy of each patient . □
•	Only administrators can control the properties related to users which are the inserting , deleting or updating the information and user accounts. □
•	Each patient can modify their health-care or personal record by inputting new data or update the existing data . □
•	Doctors can also retrieve information from the patient records and update it when needed . □
•	Each user can manage their settings part and update it. □



4. Non-Functional Requirements: 
a. Brief Description: 
Describe how well your whole system should work. Is it about being fast, easy to use, or something else? Use simple words to explain each idea. 
    Nonfunctional requirements are used to evaluate how well the system works, as opposed to examining the system's precise behavior. The system architecture outlines the strategy for putting the nonfunctional requirements into practice. It outlines the intended functioning of the system. 
Our main focus goes to developing a system that outlines high performance , availability, user-friendliness , strong security and sustainability. During designing and implementation stages we aim to create a product that does not decline when multiple users are interacting with the product at the same time . The system will be able to operate without crashing when the number of appointments increases . Our purpose is to develop a system in which each user’s private information is stored securely . The final aspiration is to develop a product which is straightforward and easy to use for everyone . Clients can book their appointments and doctors can handle their schedules easily . 


b. Acceptance Criteria: 
1.	System Performance: 
Processing Time : The time it will take to process a report should only be a few seconds.
Response Time: The system must be able to function without interruption and react fast to commands without pausing.
2.	Usability
The interface of the system should be intuitive as well as simple to use, with prompts and instructions that are clear to all users, system interfaces should be created with a minimum amount of color and background. 
3.	Security
Security refers to the requirements for safeguarding the system and its information. There are several ways to express security measurements. Several factors include the amount of time and effort required to gain unauthorized access to the system, as well as the level of competence required to breach its security . 
4.	Sustainability
Reliability is the degree of software trustworthiness. If and how frequently the system malfunctions in its ability to function. The system's mean time between failures serves as an indicator of reliability.
5.	Availability
The system should be available 24/7 and have backup and recovery capabilities in place to ensure that it is always available.

5. Application Specifications: 
a. Architecture: 
System architecture : 
The system's architecture outlines its main elements , their connections, and how they interact with one another. Business strategy, individuals , interactions, design, and it’s IT environment are all included in software architecture and design. 
Software architecture acts as the system's structure. It allows coordination, interactions, and control of complexity among its various components. All technical and operational requirements are given a systematic respond to when nonfunctional decisions related to the system architecture are made. It maximizes quality features such as performance and security. It includes choosing an organization for software development that will affect the end product's overall effectiveness, accessibility, efficiency, and quality.


•	Model: The data and business logic of the application are represented by :  appointments, users ,clinics, and other entities are included.
•	View: The view part  is made up of the presentation layer,  dashboards, calendars, and forms.
•	Controller: Controllers manage requests, interpret information from users, and produce answers. They serve as a link between the view and the model, facilitating the correct execution of application logic and data flow.



•	Interactions:

Requests are made by the user to engage with the view :  arranging appointments, browsing available periods.
In order to retrieve or modify data, the controller receives these requests, processes them, and communicates with the model.
In addition to interacting with the database to get or save data, the model carries out business logic actions.
After processing, the controller delivers the data back to the display so that the user may see it.




System components : 
•	User-interface (UI) ,  : Here each user will interact with the product in order to book the appointments. This interface ensures that each user can view available hours of the selected doctor , input their medical details and personal information. From the doctor’s perspective the interface provides the possibility to handle their schedules , view their free hours and access relevant patient information. 
•	Appointment mechanism : This component is classified as primary according to it’s importance . It controls the whole process of booking the appointment while inspecting each doctor’s available hours and also making the particular adjustments into the doctor’s personal schedule when an appointment is being reserved . 
•	Database : In charge of storing each user’s personal records according to doctor’s and patient’s perspectives.
•	Admin’s side : Consists of a back-end component related to the administrators of the system . Here the admins can insert or delete users from the system or make particular modifications according to schedules , calendars and user personal information.
•	Information safeguard : A component that ensures the protection of personal information by utilizing encryption and access control tools in order to act in accordance with security and healthcare regulations. 


 



 


This schema represents the relationship between presentation layer , application layer and data layer. Presentation layer consists on the user interface from patient , doctor and admin perspective. Application layer actually performs the required functionalities and requirements while retrieving , inputting or deleting data from the database server that represents the last stage of this schema which is data layer. 




b. Database Model: 

•	Tables:
1.	User
2.	Admin
3.	Doctor/Dermatologist
4.	Patient
5.	Sessions
6.	Specialties
7.	Appointments


•	User table will consist on user email and user type fields . The primary key here will be user email . 
•	Admin table will consist on user email and password . Here the primary key will be user email . 
•	Doctor table will have doctor id , doctor email, doctor clinic, password , name , surname and specialties fields. The primary key is doctor id.
•	Patient table will consist on patient id, patient full name , email , address and password. 
•	Specialties table that accords with what doctors are specialized in , will be divided into specialty id and specialty name. 
•	Session table will contain only one field : session time that will serve as a primary key of this table. 
•	Appointment table provides the relationship between doctor , patient and session tables . It contains it’s own primary key : appointment id and three foreign keys referencing to patient table (patient id ) , doctor table (doctor id) and session table (session time ) . This table contains also a date field which stores the date for the particular appointment . Appointment part contains data regarding scheduled appointments, such as the date, time, patient information, and services.


•	Relationships:
Patients can book multiple appointments in different periods . Doctors can have many appointments with various patients . This is recorded in appointments table . ( Many to many relationship). 
In appointments table doctors , patients and sessions are connected together through each row associated with the particular date. 
Each doctor can have one or multiple specialties , and each specialty can be divided across multiple doctors. (Many to many relationship) . 
Each admin is in control of users , patient and doctors and various system functionalities . (One to many relationship)
Patients are able to schedule many appointments.


•	The constraints:

To maintain referential integrity between tables, foreign key restrictions are used.
Double entries are prevented by unique constraints.
Organizational policies, including legitimate appointment times and dates, are enforced by check limitations.

c. Technologies Used: 

•	Back – end : The script will be typed in PHP language . The reasons behind the chosen language are : openness and free accessibility , it can be accommodated with many operating systems . PHP is a language that allows incorporation with css , js and html web-based languages which will be essential for the front-end part. Lastly this language is associated with object oriented programming features (OOP)  which provides the possibility to reuse code through inheritance principles or divide the large software product into smaller components through modularity . Related to database management MySql is chosen for its flexibility and ability to handle complex queries .The system can be accessed by using XAMPP and hosting it on localhost.
•	Front-end: The front end is the user interface of the system. There are used technologies of development like Html , Css , Javascript , Bootstrap that are responsive and easy to use. Javascript is selected according to it’s dynamic features . It provides animation formation ,  manages the inputs and client-side . Bootstrap is incorporated according to it’s responsiveness , since the purpose is to create a software applicable for smartphone, desktop and tablet . Also this technology offers the designing and implementation of web pages faster with the help of it’s predetermined practices and designs. 
•	 Security : HTTPS for secure communication ,authentication system for user management.






d. User Interface Design: 

•	Dashboard: A summary of upcoming appointments and easy access to tools for scheduling.
•	Appointment Scheduler: Forms for inserting patient information and service preferences, calendar view for choosing available times.
•	User profiles: Users can examine and edit their appointment history and personal information.
•	Admin Panel: A management interface for users, clinics, and appointments used by administrators.

Homepage : 
The homepage will consist on the system’s logo and system’s name . In the header part will be included the contact information and the phone number. In the navigation bar will be included an about page , doctors page which consists on some information about specific doctors and the sign in and sign up features . In the center of the homepage users will see “find doctor” button . After clicking find doctor they will enter the booking stage. In the main part of the homepage there will also be included some relevant information and registration features where you can register as doctor or patient. 

When user registers as patient and clicks “find doctor” there will be displayed the doctors and their available hours through a calendar. After the patient choses the appropriate time and date he makes the reservation through the button “ book the appointment ”. Next he receives a confirmation message that the appointment is made. After the booking is closed the patient can cancel it through clicking the button “cancel”. 

            Patients information: From the doctor’s perspective when he wants to access patient’s   information a search bar will be included in order for him to search patients based on their name or other . After he choses the patient , there will be displayed the patient’s medical history and contact information. Doctors can also perform functionalities like cancelling the appointment through the button “cancel”. 

             Settings part : Where users can update their personal information and medical records when needed . 


How users will interact with the system , visual representation : 

 




•	Properties that user interface must have:
1) Make user interfaces appear basic and "invisible." Make every component a service.
2) Observe the user's gaze and focus on the arrangement .
3) Ensure that elements, such as buttons and other common elements, function consistently.
4) Continue to have a high discoverability
5) Reduce the amount of steps required to complete a task.
 6) Locate controls close to important objects
7) Apply reusable design principles
8) Take into account defaults and lighten the load on users.



e. Security Measures: 

•	Encryption : The transmission of data between the client and server is encrypted using the HTTPS protocol.
•	Authentication: user authentication and session management through an authentication system.
•	Authorization : Depending on the user role (e.g., dermatologist, receptionist, admin), role-based access control might limit access to sensitive functions.
•	Password Security : Use bcrypt to save encrypted login credentials so that they remain secure even in the case of a database hack.



## Phase 3 : Software design and modelling
## Group name : Team 5 
## Uploaded by Pegi



Software architecture : 
System architecture :
Our website called “Dermo-Aesthetic Appointment System” was created to make it easier for patients and dermatologists in aesthetic clinics to schedule and manage visits. It is made up of multiple components that are interrelated that function as a unit to offer a smooth user experience.

Patients can use the online system to handle their appointments, view available timetables, and plan appointments according to their preferences. Dermatologists have access to control patient appointments, check their own schedules, and amend their availability. 

Component diagram :
Components description : 
•	Front-end component : When user communicates with the program the front-end component sends the request to the back-end server for example when a client signs in the frond end sends the request to the back-end which communicates with the database in order to store the information. The back-end server operates regarding to these requests by validating and verifying the information from inputs and connects with other components such as authorization system or database system . When the back-end server has performed the required operations for example checking appointment availability or booking an appointment , the response is produced and it is sent back to the front-end which modifies the user interface properly.
•	Back-end server and the database components : The back-end server connects with the database to get or save the information needed regarding different functionalities that the application offers . For example when the patient requests the free hours of the specified doctor , the back-end retrieves that information from the database and displays it to the patient . When the back-end processes requests from different users , it modifies the database , for example when a user cancels the appointment , the database is modified by adding a new available hour for a particular doctor. 
•	Authentication , authorization and back-end server : When the user logs into the platform or takes an action that requires authorization (such as booking an appointment ) , the frontend transfers the login information into the back-end server . The back-end server communicates with authorization and authentication component to make sure that user’s data is verified and valid . By checking the authorization status and particular user roles the back-end server judges if the user is permitted to perform the specified request. 
•	Booking engine and back-end server : The booking engine is connected with the back-end server , because when the user requests to book an appointment , he actually executes the booking algorithm which is performed in the back-end side. This algorithm is indicated by some other factors which are available hours , doctor’s timetable , what client selects according to doctor preference or time and date preference . When the client actually performs the operation of choosing the date , time and doctor the booking engine modifies the database and sends the confirmation message to all parties involved in the process. 
•	Esthetician management and back-end component : The back-end server facilitates the maintenance of profiles and availability for estheticians . When esthetician reloads the page or refreshes their schedule , the back-end component assesses these modifications and modifies the database . The frond-end part may be also connected with the back-end part to display esthetician profiles such as the available hours for esthetician varying on the current modified information .
•	Notifications and back-end server : The notification component is linked to the back-end server to transfer notifications to the users , for example when the booking process is performed the back-end component sends the request to the notifications side that indicate that kind of response . The notification side assesses these requests and delivers the message to the appropriate parties 
   
  Component diagram : 

 
	

Sign in feature : 
 
Log in feature : 
 

Detailed design : 
Class diagram :

 
Classes : 
1.	User 
2.	Doctor
3.	Patient 
4.	Admin 
5.	Appointments 
6.	Sessions
The user class will contain it’s own attributes : user ID , username , password and email . Admins , patients and estheticians ( doctors ) primarily log into the system as users . The user class will contain the functions log in () and sign up () , which take as parameters username , password and email . Both of the functions return types are Boolean . 
The doctor class will contain the attributes : doctor ID , doctor email , clinic , password , doctor name and doctor surname . The functions related to doctors are view calendar() where doctor checks his schedule . The function takes as parameter the date . The second is add appointment() where the doctor adds an appointment . The function takes as parameter the date and time . The third function is delete appointment() where the doctor cancels the appointment. The function’s return types are Boolean . 
Patient class will contain the attributes Patient ID, Patient Name , Email , Address, Password. The functions related to patients are create Appointment () where the patient books the appointment . The function takes as parameter the doctor ID , date and time . The second function is cancel Appointment () where the patient cancels the appointment previously booked . This function takes as parameter the appointment ID . The function’s return types are Boolean . 
Patients class and Doctor class are directly related with the Appointments class. The appointment’s attributes are patient ID , doctor ID , date , time and appointment ID . The functions related to appointments are postpone Appointment() where the patient postpones the appointment to another time . The function takes as parameters the date , time and appointment id ( that will be postponed ) . The second function related to appointments is remove Appointment () which takes as parameter the appointment ID ( that will be removed ) . The function’s return types are Boolean . 
The session class is directly connected with doctors assuming that the doctors are the ones in control of sessions . Session class contains the attributes doctor ID and session time . The functions related to sessions class are book session () which takes as parameter patient ID , and remove session () which takes as parameter patient ID . Both these function’s return types are Boolean . 
Specialties class is related to doctor’s specialties . It contains the attributes : specialty ID and specialty name . 

##Uploaded by Kevi
##Sequence diagram : 
1.	Appointment request by client : 

 

In this diagram patient communicates with the application through the front-end side in order to book an appointment . The front-end transfers this request to the back-end side and the back-end shows to the user all the services that can be performed by estheticians . Next the back-end side starts searching into the database for appointment availableness . After this the back-end starts searching esthetician’s free hours into the database and gets this information to display into the front-end part. This information is transferred into the front-end part and patient choses the date , time , esthetician and service . This selected information is transferred again into the back-end component in order to make the appointment booking . After the appointment is booked the modifies the esthetician schedule in the database part. When this operation is fully performed the patient receives the notification that the booking is made. 

2.	Log-in sequence diagram 

 
The Client submits their login information (e.g., name and password) via the Frontend Interface. The Frontend Interface transmits the login information to the Backend Server for verification. The Backend Server checks the user's  login information against the information contained in the Database. Following successful login, the Backend Server analyzes the user's position (e.g., client, esthetician, admin) to figure out rights. Assuming the user is an admin, the Backend Server pulls their data and rights from the database.
3.	Admin modifies settings sequence diagram : 
 
In this diagram admin enters his primary information into the front-end side when he logs in . The front-end transfers this information into the back-end side to verify and validate this information in order for the admin to continue with the next steps. The back-end server authorizes admin to continue by comparing the data submitted by admin with the data that are stored in the database for that particular admin. Next the back-end server permits the admin to modify system settings . 
	






4.	Esthetician view patient information sequence diagram : 
 
Doctor requests patient information . This request goes into the database where the information is stored . Doctor searches the information with patient ID , primary key of patient entity. In order to retrieve patient’s information doctor needs authorization . When authorization is performed the doctor gets the information , in other cases when the authorization fails the application displays error message.
5.	Update esthetician information from admin sequence diagram : 
 
Admin logs in the system , and requests update from the system . The system communicates with the database in order to search for the doctor that will be updated by (Doctor ID) . To perform this activity administrator needs authorization . If authorization is correct the application displays ok and the update is done. 



 







## Database design : 
## Database model 
## Uploaded by Enxhi
 

•The data within the application is organized through the following tables : 
1.	Patient 
2.	Admin
3.	Doctor
4.	Session 
5.	Appointment 
6.	Specialties
7.	Doctor Specialties
   
The respective attributes for each table are as follows : Patient ( Patient ID, Patient Name , Email , Address, Password ) .
This table will store information about each patient . The doctor’s table attributes are : Doctor ( Doctor ID , Doctor Email , Doctor Clinic , Password , Doctor Name , Doctor Name , Doctor Surname ) .
Admin table consists on the attributes , Admin ( email, password) . The session table will be divided into : Session (Session Time , Doctor ID foreign key referencing Doctor ID in Doctor table ) .
Specialties table will consist on the attributes : Specialties (Specialty ID, Specialty Name).
Doctor Specialties table represents the relationship between doctor and specialties . It contains two attributes each of them foreign keys ( Specialty ID referencing Specialties and Doctor ID referencing Doctor ) . Appointment table represents the relationship between doctors and patients , containing the foreign keys : Doctor ID referencing Doctor and Patient ID referencing Patients . It has two other attributes : appointment ID and date.

**Relationships :**
 • Doctors and Sessions : The table Sessions shows the doctor’s free hours in order for the patients to book   appointments . Each session is connected with one doctor and one doctor is associated with many sessions . One to many relationship. 
 
• Patients and appointments : In the appointments table is stored information related to patients who book appointments regarding to a specific doctor , meaning that one patient can book many appointments and one appointment is associated with one patient . One to many relationship. 

• Doctors and specialties : The table doctor specialties represents the relationship between doctors and their particular specialties . Since each doctor can have many specialties and one specialty is associated with many doctors this is a Many to many relationship.

• Doctors and appointments : The relationship between doctors and appointments exists in the table appointments where each patient books appointments regarding to a specific doctor. One doctor has many appointments booked , while one appointment is associated with one doctor . One to many relationship. 

    **The efficiency of data storage is provided through following a variety of principles :**   
  
  Normalization : Normalization procedure is followed in order to reduce anomalies and data redundancy . This ensures that the database is well organized , data is integrated and redundant information is eliminated . 
  
  Query improvement : We have ensured that query writing is structured and logical while maximizing database performance by using appropriate indexing techniques . 
  
 Continuous support : Meaning that queries running , operations , executions and resource handling are under continuous observation. This provides higher capabilities and performance according to the overall database system .        
  Schema outline for higher flexibility : Keeping in mind that the data being entered will increase overtime , we have designed a database schema appropriate and flexible regarding to voluminous information .

## Modelling :
## Uploaded by Sindi
Use case diagram 

  Use cases :
Patients log-in or sign-in into the system , book the appointments or cancel the appointment .They can leave the system by deleting their existing account. They can modify their personal account due to their preference. 
Doctors can view online their future or current appointments booked in the system . They can check the patient’s information including medical history to be more informed before the examination of patient. They can delete their existing account and modify personal account.
Admin : They can insert new accounts for doctors or remove their accounts from the system. They are in charge of controlling doctor’s sessions by adding new sessions or deleting sessions that are primarily booked by patients . They can update doctor’s information within the system.

Activity diagram : 
Patient booking the appointment activity diagram : 

This diagram explains how patient interacts with the system when he wants to book an appointment. After logging in the patient selects “book appointment “ functionality that the application provides. When the system interacts with the database , it displays into the front-end side all the services that the doctors provide. Patient then can select the type of service he wants based on the preference . After selecting the service , system interacts again with the database in order to retrieve the doctors that provide the service required. Patient choses the doctor and the back-end transfers the available sessions of that doctor retrieved from the database component into the front-end component . The available hours are displayed and patient selects the session appropriate for him . When this process is actually completed successfully the system notifies the patient that booking process is completed . 

Admin updating doctors information activity diagram : 
This diagram describes the process  of administrators performing changes into doctors . Admin firstly logs into the system with his credentials . The two options provided for him are insert new doctor or overview doctors . When admin overviews the doctors he actually searches for one particular doctor and the back-end gives that information after searching into the database with the doctor’s id . That doctor’s data is displayed into the front-end side and admin choses either to delete that doctor from the system , thus deleting his records from database or just get this information for his own purposes . When admin wants to add a new doctor in the system he selects the option “insert doctor “ and the system requires from him to complete the fields with information regarding that doctor that will be added . When admin clicks “save” this new record will be stored into the database and can be retrieved whenever he wants . 

Doctor updating his schedule activity diagram : 
In this diagram are described the modifications that doctor can make regarding to his schedule . At first doctor logs in with his credentials , then the calendar is fetched from the database meaning that the back-end requests from the database to transfer that doctor’s personal schedule . When the schedule of the doctor is displayed into the front-end , doctor can chose to add a new session . When he clicks “ add new session “ he selects the date and time for this session through the user-interface . This information is saved and is inserted into the sessions table at the database . The process is completed and the doctor receives the confirmation notification . 
In other cases when the doctor wants to cancel an appointment he performs the same steps except the part when he selects “cancel session “ through the user-interface. The doctor selects the session to be canceled , he cancels the session and clicks save . This information is then updated in the database . After cancellation process is completed he receives a confirmation notification . 

Patient log-in sign in activity diagram : 
In this diagram is described the patient’s log-in and sign-in that this application provides . When the patients logs in he inputs his personal information and the back-end checks this information by comparing the data that the patient inputs with the data that is actually stored in the database . If he has typed the right username and password patient can overview the dashboard through the user’s interface because back-end has retrieved the patient’s personal information fetched in the database for that patient. When the patients signs up for the first time , he inputs his credentials while the back-end authenticates and validates this information . If the information is valid then , new account is created for this patient . The dashboard is displayed through user interface and new records of this patient are stored in the table patients within the database . 

State diagrams :
State diagram for appointment booking process : 
Start: The booking process begins .
Appointment process :This state is a prime example of the fundamental procedure used to schedule appointments.
New process : The software receives a fresh request for an appointment .
Handling the demand:  This stage shows that the software is handling the appointment request, confirming for availability, and verifying the data provided.
Valid Time Slot: If the time slot becomes vacant after reviewing the request, it enters this state, giving a signal that it is ready for reservation.
Pending Verification: If either the patient or the esthetician arrange the appointment, it moves to this state. It is holding once verification has been submitted.
Confirmed Appointment: In this case, those involved (patient and esthetician) agreed on the date and time and it is arranged.
End: Final stage where the process is done.
Phase IV - Software Testing

1.Introduction to Testing:  
Software testing acts as a critical part with its essential role during software development. This phase covers a variety of test tasks assigned to each component that makes up our software in order to recognize bugs or various defects that have arisen. During this phase we execute the application and discover how it reacts to particular inputs or situations in order to determine whether the application developed provides efficiency and the functionalities required from stakeholders or customers. This way we verify the accuracy, dependability, capacity, potential and behavior. Software testing process ensures that PHP code complies with the specification and meets the requirements. This is an important part to examine the functionality of a component and how it works.
1.	Defect recognition : Testing contributes to identifying weak spots of the application and resolving the deficiencies and differences between the current and the predicted state and software’s way of acting. By recognizing the problems early we aim to resolve and put a stop to particular problems that might become apparent in the future. 
2.	 Quality guaranteeing : General quality and functionality of the software can be enhanced through testing. It validates our product according to pre-established benchmarks or standards along with verifying whether the application meets what the customer wants, usefulness and safety. Through conducting frequent testing tasks we assure that the product distributed conforms to the predetermined specifications and adds business value. 
3.	Risk management : Testing contributes widely in moderating the risks. We evaluate the influence of probable collapses or weaknesses through testing and identify quicker the fields for advancement. 
4.	Constant advancement : Through its iterative development and approach, testing can contribute to our team in terms of recognizing different possibilities for improvement, clarify requirements while making it flexible and cost-effective when the business needs shift. By distributing high performance and value to stakeholders and business through testing we meet customer expectations. 
 
2.Purpose of Testing:
Testing code is a significant part of a software development. The aim of testing is to identify various functional problems, improve quality, change and fix errors as mentioned before. In the appointment booking application’s circumstances, testing is critical for making sure that this application meets the functional and non functional requirements.
1.	Recognizing errors in early stages : Through structured testing tasks we come across concerns related to performed functionalities of the application, along with incorporation with other systems and exterior environment , data verification and user satisfaction. We recognize errors in early stages through : 
•	Unit testing : We employed unit testing in validating the behavior of units or components that the application encompasses. Through executing the software with a structured set of inputs we check whether the components perform their predetermined functionalities. We test separate functions of the codebase, various algorithms applied , classes as whole and how these individual components/units are incorporated with other components within the software. Some examples of unit testing might include user credentials confirmation functions such as login() or sign-in(), notification functionalities such as testing sendConfirmation() function, appointment handling engine such as book appointment() function, database testing such as fetch appointments according to esthetician schedule or patient. 
•	Integration : Here we check how these single components mentioned before connect and interact with each other. Some integration tests might be : 
1.	Database integration : We test whether the database component properly communicates with the appointment booking component to insert, delete or modify information into the database. This is done through storing an artificial appointment information into the database and checking whether the appointment brought back from using the functions in the Appointment component matches the one we previously inserted into the database component. This is accepted only in cases where we retrieve the correct information. 
2.	Checking the user credentials when they log in or sign in : Here we check the communication between appointment and authentication components. This is done through artificially log-in and seeking to book an appointment. The integration test is only accepted in cases when after the log-in operation is performed the user can successfully book an appointment.
3.	User interface component and appointment management component : Here we check whether the Appointment component integrates properly with the UI component. The tests are performed through accessing the user interface and booking the appointment through it. This type of test is accepted only if this action is performed without generating error.
4.	Notification component integration : The notification component is integrated with the appointment component. This interaction is tested through artificially booking an appointment and waiting to be notified that the appointment is made. 
•	    System testing : System testing is done through executing the overall software to test whether it fulfills the requirements , criteria and is incorporated properly into the entire environment.
1.	Booking service : Testing the whole appointment booking operation from the moment when the user interacts with the front-end until the database modifies. This test is performed through artificially entering log-in data , next the application displays the doctors and after that, the appropriate hours are shown. The appointment request is transmitted and the notification is displayed. If the database is modified meaning that a new row is inserted involving the data inputted from the request then this test is accepted. 
2.	Safety test : This is done by evaluating the entire security system. Tests related to security can be performed through trying to complete prohibited operations without proper user authorization or trying to have access to other user’s personal information. Safety tests protect the whole system from data corruption and ensure that access is limited towards user’s personal information and other areas that require configuration. 
3.	Compatibility : Testing the web application from various browsers and digital tools  to ensure that it responds similarly from each of the browsers and devices , thus making sure that the application is responsive and performs the requirements similarly in different devices and from different browsers. 
4.	Booking conflict settlement : This test is responsible for making sure that the system limits conflicting bookings or settles the confrontations between these bookings. The test is done through requesting appointments with similar details(like similar date and time with similar estheticians) and observing how the system behaves. The test is accepted only if the system recognizes the confrontations between these appointments and sends the proper notification to the user (f.e This time is not available, try another time). 
•	    Acceptance Testing :  It aims to show that the application performs what the business and the user expects from the application along with fulfilling the intentions of various stakeholders involving estheticians, patients, admins etc. Acceptance standards depend on user stories , user and system requirements and the acceptance tests are only accepted if these standards are met. 
3. Testing a single component 
1.	Appointment class : Appointment class is essential related to appointments service in terms of encompassing the fundamental functionalities of adding, canceling or modifying(postponing) appointments. These are critical , because the entire mechanism of the application can be impacted if bugs or deficiencies exist in this component. This component is defined as complex because of the continuous verifications of data and the communications of this component with other components (f.e with the notification system , UI , database ). This component makes sure that the user inserts , deletes or modifies appointment data without interacting directly with the database. Appointment component is the most important one because the functionalities it offers are prioritized by users , meaning that the users aim to book appointments quickly and without errors, overview correct calendars and be notified whenever they book an appointment , cancel an existing one or postpone it. Lastly as the software users increase and the user’s requests for bookings grow faster the performance tests must be performed. Performance testing means that the system is able to manage multiple bookings or other user requests without reducing performance. 
2.	Notifications: Notification component is responsible for notifying users whenever their booking was successful , the appointment is deleted or the appointment is postponed. Notifications component is crucial because it creates a friendlier interaction between users and the system by continuously notifying them after executing an action within the system. Notification tests can be done by executing different actions and waiting for the application to react by sending notification messages to the user. 
3.	User verification: Through this component users can be authenticated and authorized to perform a variety of actions involved with each user role. This component is defined as complex because it validates and verifies each user through interaction with the database where user information is stored along with overseeing the sessions and being in compliance with security measures. It is crucial because it is responsible for the overall system’s safety and data security. User verification tests can be performed by inputting valid or invalid credentials and observing how the system behaves in these situations. 
4.	Booking Interface: This component is crucial and primary user interface for making reservations with estheticians. Furthermore it is more than a need,  towards providing clients a smooth and straightforward process while planning their choice of goods or services. By making appointment scheduling easier than ever, the Booking Interface component contributes significantly to customer pleasure and participation. It is tested for responsiveness, ease of use, and usefulness among a variety of platforms and resolutions. Moreover, it guarantees that consumers are able to rapidly browse existing schedule slots, pick desired activities, and finish the scheduling procedure before facing unwanted difficulties or mistakes. Via rigorously evaluating the Booking Layout, we provide a user-friendly yet effective booking experience, promoting friendly relationships among consumers to the reservation process.
5.	Admin dashboard: Unit examination performed by the Admin Dashboard section verifies that every module or classes works properly inside the esthetician appointment booking system's administration interface. Tests examine performance, speed, and safety measures, ensuring managers have a dependable and simple to operate interface.

       4. Test Cases : Here we describe some of the main test cases that ensure the functionality expected from the software. 
1.	System limits patients when they try to book an appointment from the past. 
•	This is done through requesting an appointment within a past date and observing how the system reacts to this type of input. 
•	 The test case is only accepted when the system generates an error and requests the user to enter another time for the appointment. 
2.	User V&V test 
•	The test is performed through inputting the correct credentials for log-in or sign-in and waiting for the system to display the home page. 
•	The test is accepted only if the user can log-in quickly and perform his operations after. 
3.	Users with invalid information are declined from the system when they try to log into the platform. 
•	This test is done through trying to enter incorrect data when logging in. 
•	The test is only accepted in cases when the system after receiving this incorrect information notifies the user to enter his information again. 
4.	 The notification component sends the confirmation notification to the patient booking the appointment.
•	The test is done through booking an appointment and waiting for the confirmation notification. 
•	The test is only accepted if after booking the appointment successfully the system notifies the user. 
5.	Appointment postponement testing 
•	The test is performed to ensure that patients can postpone the appointment to another time. 
•	The test’s tasks are : log-in the application with the correct credentials, go to “my appointments” and select the appointment that needs to be canceled or postponed, click the button postpone and after that you are requested to enter the new date and time. The application confirms this operation by sending a notification that the appointment is postponed. 
•	The test is only accepted if the appointment is postponed and the new date and time are displayed into “my appointments” section while confirming this process with the notification in the end. 
6.	Delete an appointment testing 
•	This test is performed to ensure that the patients can cancel/delete their booked appointments.
•	For this type of test we need to log in as a user and then go to “my appointments”. There we choose the appointment that needs to be canceled and click the button “cancel”. After this operation is done the system notifies the user for the cancellation made. 
•	This test case is only accepted if the appointment can be deleted and the data being removed is demonstrated in the patient’s upcoming appointments and in the database holding the appointments data while confirming this whole process with the notification in the end. 
7.	Test case for invalid input
•	The test is done through trying to enter unacceptable input for example absent information into the fields that need to be filled and unacceptable formation of password or username.
•	The test is accepted only when after entering invalid data the program generates an error and requests to enter the information again. 
8.	Test case for user-interface accurateness in showing the appointments date , time and other specifications.
•	This test is done through logging into the system and trying to book appointments with different specifications. After getting the confirmation , we go to the appointments list and check whether the predetermined appointments specifications are shown correctly into the list. 
•	The test is accepted if the User Interface shows the appointments entered previously exactly and without errors involving all the time date and esthetician specifications. 

5.Choosing Testing Frameworks:
For the testing phase we have chosen PHPUnit due to the fact that the code is written in php language. This testing framework is broadly employed in the testing phase since it is the usual framework for this type of language. It supports a variety of assertions and functionalities for developing extensive unit/component tests. PHPUnit involves persistent and continual servicing and progress with new functionalities being added frequently. Lastly the community assists you with all-inclusive documentation and instructions easy accessible. 

1.	Homepage Interface : 
 


2.	Here we test how the verification component behaves when a user tries to sign in with credentials used before. This test case is done through inputting the data inserted before in the application and the test is only accepted if this component notifies the user that the data inserted by him is used before. 
 
 




Output : 
 

3. Testing the authorization and verification component when the user logs in with valid credentials. This is done through clicking log-in and entering username and password. This test is accepted when the component verifies the user by retrieving the data from the database holding that user’s data and displaying the patient dashboard. 

Output : 
 

The appointments schedule for the patient : 
 

This test case is performed to test whether the system, after displaying the searched doctor name and location, displays the doctor’s information for example name, email, specialty, city and events. The inputs are doctor name and location , after clicking search we wait for the outcome results. The test is accepted only if after performing the operations mentioned above the doctor’s specifications are displayed.
Test:
 
Output : 

 

6.Writing Test Code:
Setting up composer and phpUnit to write and run tests: 
 
Checking version :
 
Configuration file : 
 
Modify Json file : 
 
Testing user service class : 
Code : 
<?php
use PHPUnit\Framework\TestCase;

require_once __DIR__ . '/../services/userService.php';

class UserServiceTest extends TestCase
{
    private $userService;
    private $db;

    protected function setUp(): void
    {
        $this->userService = new UserService();
        $this->db = DbConfig::getConnection();
    }

    // Test cases for createUser
    public function testCreateUserSuccess()
    {
        $result = $this->userService->createUser('p', 'newuser', 'password123');
        $this->assertTrue($result);
    }

 
    // Test cases for getUser
    public function testGetUserExistingId()
    {
        $user = $this->userService->getUser(3);
        $this->assertIsArray($user);
        $this->assertEquals('3', $user['uid']);
    }

    public function testGetUserNonExistingId()
    {
        $user = $this->userService->getUser(999);
        $this->assertNull($user);
    }

    // Test cases for updateUser
    public function testUpdateUserSuccess()
    {
        $result = $this->userService->updateUser(1, 'user', 'updateduser', 'newpassword123');
        $this->assertTrue($result);
    }

   

    // Test cases for deleteUser
    public function testDeleteUserExistingId()
    {
        $result = $this->userService->deleteUser(2);
        $this->assertTrue($result);
    }


    // Test cases for listUsers
    public function testListUsersNotEmpty()
    {
        $users = $this->userService->listUsers();
        $this->assertNotEmpty($users);
    }

   

    // Test cases for getPatients
    public function testGetPatientsNotEmpty()
    {
        $patients = $this->userService->getPatients();
        $this->assertNotEmpty($patients);
    }

 

    // Test cases for getDoctors
    public function testGetDoctorsNotEmpty()
    {
        $doctors = $this->userService->getDoctors();
        $this->assertNotEmpty($doctors);
    }


    // Test cases for getSpecialities
    public function testGetSpecialitiesNotEmpty()
    {
        $specialities = $this->userService->getSpecialities();
        $this->assertNotEmpty($specialities);
    }

  

    protected function tearDown(): void
    {
        
    }
}











Running tests
Command : ./vendor/bin/phpunit --testdox  .\tests\UserServiceTest.php  
Testing user service class : 
Output : 

 





Testing appointment service class : 
Code : 


<?php
use PHPUnit\Framework\TestCase;

require_once  __DIR__ . '/../services/appointmentService.php';

class AppointmentServiceTest extends TestCase
{
    private $appointmentService;
    private $db;

    /**
     * @throws Exception
     */
    protected function setUp(): void
    {
        $this->appointmentService = new AppointmentService();
        $this->db = DbConfig::getConnection();
    }

    // Test cases for bookAppointment
    public function testBookAppointmentSuccess()
    {
        
        $_SERVER['REQUEST_METHOD'] = 'POST';
        $_POST['doc_id'] = '1';
        $_POST['pid'] = '3';
        $_POST['date'] = '2025-05-10';
        $_POST['time'] = '10:00';

        // Expect output to contain success message
        $this->expectOutputRegex('/Appointment booked successfully/');
        $this->appointmentService->bookAppointment();
    }

 

    // Test cases for getAppointment
    public function testGetAppointmentExistingId()
    {
        // Use a known appointment ID that exists
        $appointment = $this->appointmentService->getAppointment(8);

        // Assert the expected outcome
        $this->assertIsArray($appointment);
        $this->assertEquals('8', $appointment['app_id']);
    }

    public function testGetAppointmentNonExistingId()
    {
        // Use a non-existing appointment ID
        $appointment = $this->appointmentService->getAppointment(999);

        // Assert the expected outcome
        $this->assertNull($appointment);
    }

    // Test cases for updateAppointment
    public function testUpdateAppointmentSuccess()
    {
        // Call the method with new data for existing appointment
        $result = $this->appointmentService->updateAppointment(1, '2', '1', '2024-05-11', '11:00');

        // Assert the expected outcome
        $this->assertTrue($result);
    }

   

    // Test cases for cancelAppointment
    public function testCancelAppointmentExistingId()
    {
        // Call the method with an existing appointment ID
        $result = $this->appointmentService->cancelAppointment(1);

        // Assert the expected outcome
        $this->assertTrue($result);
    }

  

    // Test cases for listAppointments
    public function testListAppointmentsNotEmpty()
    {
        // Call the method
        $appointments = $this->appointmentService->listAppointments();

        // Assert the expected outcome
        $this->assertNotEmpty($appointments);
    }

   

    protected function tearDown(): void
    {
        // Clean up your database or mock objects here
    }
}







Running tests :
Testing Appointment service class : 
Command : ./vendor/bin/phpunit --testdox  .\tests\AppointmentServiceTest.php 

Output : 
 

 
 
8.Test Coverage:
Test coverage facilitates the process of identifying the areas inside your program that require testing. If there is insufficient test coverage, defects in untested code may go unnoticed.
Improving Confidence: A higher level of test coverage gives you more assurance that your tests are adequately validating the behavior of your code. It lessens the chance that untested code paths have undiscovered bugs.
Raising the quality of the code: More modular and well-designed code is often the outcome of creating tests. High test coverage is the goal to encourage writing testable and maintainable code.



















